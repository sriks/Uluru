default_platform(:ios)

platform :ios do
  
  desc "PR Check"
  lane :pr_check do
    scan
  end

  #######################################################################
  # Tests
  #
  desc "Run tests"
  lane :tests do
      scan
  end

  #######################################################################
  # Release preparation
  #
  desc "Prepares for release by updating version number as per semver."
  desc "Intended to run locally."
  desc "options[:type]: 'major', 'minor' or 'patch'"
  lane :prepare_release do |options|
      type = options[:type]
      fetch_all_tags
      # Last git tag can be nil if the repo have no tags so far.
      version = last_git_tag
      if version.nil?
          puts "git tab not found. Using 0.0.0"
          version = '0.0.0'
      end

      # Get next logical version from last git tag.
      version = next_version_from_old_version(version, type)
      podspec = "#{ENV['FRAMEWORK_NAME']}.podspec"

      # Prepare commit based on user decision.
      commitMessage = "Updated version to #{version}"
      text = "
          IMPORTANT: You should do this step on your local machine after committing all code changes and git status is clean. 

          This step will ...

          1. Update Info.plist(s) to #{version}
          2. Updated #{podspec} file to #{version}
          3. Commit the changes with the message \"#{commitMessage}\"

          What you should do ?

          1. Make sure to push the changes.
          
          Do you want to continue ?"

      shouldContinue = prompt(text: text, boolean: true)

      if shouldContinue 
          # Make sure git status is clean 
          # ensure_git_status_clean(show_uncommitted_changes: true)

          # Update proj to new version
          increment_version_number(version_number: version)

          # Update podspec to new version.
          version_bump_podspec(path: podspec, version_number: version)

          # Lets commit the code
          # sh "git commit -a -m \"#{commitMessage}\""
          # puts "Make sure to push the changes."
      end

  end

  # Returns the next logical version from old_version based on bump type by following semver.org.
  # Accepted bump types are 'major', 'minor' or 'patch'
  # next_version_from_old_version(1.0.1, 'patch') will return '1.0.2'. Note that there is no 'v' prefix.
  def next_version_from_old_version(old_version, bump)
      # Calculates the new version according to the semantic version
      type = bump
      old = old_version
      puts "Old version #{old}"
      version = old

      oldArr = old.split('.').map{|v| v.to_i}    

      if type == "patch"
          version = "#{oldArr[0]}.#{oldArr[1]}.#{oldArr[2] + 1}"
      elsif type == "minor"
          version = "#{oldArr[0]}.#{oldArr[1] + 1}.0"
      elsif type == "major"
          version = "#{oldArr[0] + 1}.0.0"
      end   

      puts "Next logical #{type} version for #{old_version} is #{version}"
      if version == old
          UI.user_error!("Wrong release type parameter. Enter: patch | minor | major")
      end
      return version
  end

  # Fetch all tags
  def fetch_all_tags
      sh('git fetch --tags')
  end

end

